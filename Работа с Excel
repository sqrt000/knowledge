
#Область МетодыДляРаботыЧерезCOM

////Прикладные методы////
Функция ком_ПрочитатьПервыйЛистExcel(ИмяФайла, НомерПервойСтроки = 1, НомерПервойКолонки = 1, ВсегоСтрок = 0, ВсегоКолонок = 0, ОписаниеОшибки = "") Экспорт
	
	Отказ = Ложь;
		
	Эксель = ком_ПолучитьExcel(Отказ, ОписаниеОшибки);
	Если Отказ Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	КнигаЭксель = ком_ПолучитьКнигуExcel(Эксель, ИмяФайла, Отказ, ОписаниеОшибки);
	Если Отказ Тогда
		ком_ЗакрытьExcel(Эксель);
		Возврат Неопределено;	
	КонецЕсли;
	
	ЛистЭксель = ком_ПолучитьЛистExcel(КнигаЭксель, 1, Отказ, ОписаниеОшибки);
	Если Отказ Тогда
		ОписаниеОшибки = "Не удалось открыть лист номер " + 1 + ". ОписаниеОшибки: " + ОписаниеОшибки;
		ком_ЗакрытьКнигуExcel(КнигаЭксель);
		ком_ЗакрытьExcel(Эксель);
		Возврат Неопределено;
	КонецЕсли;
	РезультатЧтенияЛиста = ком_ПрочитатьЛистExcel(ЛистЭксель, НомерПервойСтроки, НомерПервойКолонки, ВсегоСтрок, ВсегоКолонок);
		
	ком_ЗакрытьКнигуExcel(КнигаЭксель);
	ком_ЗакрытьExcel(Эксель);
	
	Если РезультатЧтенияЛиста = Неопределено Тогда
		ОписаниеОшибки = "Не удалось прочитать файл";
		Возврат Неопределено;
	КонецЕсли;
	
	Если РезультатЧтенияЛиста.Количество() = 0 Тогда
		ОписаниеОшибки = "Файл пустой";
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат РезультатЧтенияЛиста;
КонецФункции

Функция ком_ЗаписатьТаблицуЗначенийНаПервыйЛист(ИмяФайла, ТаблицаЗначений, ОписаниеОшибки = "") Экспорт
	
	Отказ = Ложь;
	ОписаниеОшибки = "";
	
	Эксель = ком_ПолучитьExcel(Отказ, ОписаниеОшибки);
	Если Отказ Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	КнигаЭксель = ком_ДобавитьКнигуExcel(Эксель, Отказ, ОписаниеОшибки);
	Если Отказ Тогда
		ком_ЗакрытьExcel(Эксель);
		Возврат Неопределено;	
	КонецЕсли;
	
	ЛистЗаказы = КнигаЭксель.Worksheets(1);
	ком_ЗаполнитьЛистExcelИзТаблицыЗначений(ЛистЗаказы, ТаблицаЗначений);

	// Сохранение файла
	КнигаЭксель.SaveAs(ИмяФайла);
	
	ком_ЗакрытьКнигуExcel(КнигаЭксель);
	ком_ЗакрытьExcel(Эксель);
	
КонецФункции

////Чтение/заполнение через ComSafeArray////
Функция ком_ПрочитатьЛистExcel(ЛистЭксель, НомерПервойСтроки = 1, НомерПервойКолонки = 1, ВсегоСтрок = 0, ВсегоКолонок = 0) Экспорт
		
	Если ВсегоСтрок = 0 Тогда
		ВсегоСтрок = ЛистЭксель.Cells.SpecialCells(11).Row;
	КонецЕсли;
	Если ВсегоКолонок = 0 Тогда
		ВсегоКолонок = ЛистЭксель.Cells.SpecialCells(11).Column;
	КонецЕсли;
	
	ОписаниеТиповСтрока = Новый ОписаниеТипов("Строка");
	
	ТЗ =  Новый ТаблицаЗначений;
	Для Счетчик = 1 По ВсегоКолонок Цикл
		СчетчикСтрокой = ОписаниеТиповСтрока.ПривестиЗначение(Счетчик);
		СчетчикСтрокой = СтрЗаменить(СчетчикСтрокой, Символы.НПП, "");
		
		ТЗ.Колонки.Добавить("Колонка"+СчетчикСтрокой, ОписаниеТиповСтрока);
	КонецЦикла;
	
	Для Счетчик = НомерПервойСтроки По ВсегоСтрок Цикл
		НоваяСтрока = ТЗ.Добавить();
	КонецЦикла;
	
	Область = ЛистЭксель.Range(ЛистЭксель.Cells(НомерПервойСтроки,НомерПервойКолонки), ЛистЭксель.Cells(ВсегоСтрок,ВсегоКолонок));
	Данные = Область.Value.Выгрузить();
	
	Для Счетчик = 0 По ВсегоКолонок-1 Цикл
		ТЗ.ЗагрузитьКолонку(Данные[Счетчик], Счетчик);
	КонецЦикла;
		
	Возврат ТЗ;
КонецФункции
 
Функция ком_ЗаполнитьЛистExcelИзТаблицыЗначений(ЛистExcel, ТаблицаЗначений) Экспорт
	
	ВсегоКолонок = ТаблицаЗначений.Колонки.Количество();
	ВсегоСтрок = ТаблицаЗначений.Количество();
	
	// Создание COMSafeArray
	МассивКом = Новый COMSafeArray("VT_Variant", ВсегоКолонок, ВсегоСтрок);
	
	// Заполнение COMSafeArray
	Для Стр = 0 По ВсегоСтрок - 1 Цикл
		Для Кол = 0 По ВсегоКолонок - 1 Цикл
			МассивКом.SetValue(Кол, Стр, ТаблицаЗначений[Стр][Кол]);
		КонецЦикла;
	КонецЦикла;
	// Присвоение области листа Excel значений из COMSafeArray
	ЛистExcel.Range(ЛистExcel.Cells(1, 1), ЛистExcel.Cells(ВсегоСтрок, ВсегоКолонок)).Value = МассивКом;
	
КонецФункции

////ОТКРЫТЬ////
Функция ком_ПолучитьExcel(Отказ = Ложь, ОписаниеОшибки = "") Экспорт
	
	Эксель = Неопределено;
	Попытка
		Эксель = Новый COMОбъект("Excel.Application");
		Эксель.Visible = Ложь; 
		Эксель.DisplayAlerts=Ложь;		
	Исключение
		ОписаниеОшибки = "Не удалось получить COM-объект. Описание ошибки: " + ОписаниеОшибки();
		Отказ = Истина;	
	КонецПопытки;
	
	Возврат Эксель;
КонецФункции

Функция ком_ПолучитьКнигуExcel(Эксель, ИмяФайла, Отказ = Ложь, ОписаниеОшибки = "") Экспорт
	
	КнигаЭксель = Неопределено;
	Попытка
		КнигаЭксель = Эксель.WorkBooks.Open(ИмяФайла);
	Исключение
		ОписаниеОшибки = "Не удалось открыть файл Excel. Описание ошибки: " + ОписаниеОшибки();
		Отказ = Истина;	
	КонецПопытки;
	
	Возврат КнигаЭксель;
КонецФункции

Функция ком_ПолучитьЛистExcel(КнигаЭксель, ИмяИлиНомерЛиста = 1, Отказ = Ложь, ОписаниеОшибки = "") Экспорт
	
	ЛистЭксель = Неопределено;
	Попытка
		ЛистЭксель = КнигаЭксель.WorkSheets(ИмяИлиНомерЛиста);
	Исключение
		ОписаниеОшибки = "Не удалось открыть лист Excel. ИмяИлиНомерЛиста: " + ИмяИлиНомерЛиста + ". Описание ошибки: " + ОписаниеОшибки();
		Отказ = Истина;;	
	КонецПопытки;
	
	Возврат ЛистЭксель;
КонецФункции

////ДОБАВИТЬ////
Функция ком_ДобавитьКнигуExcel(Эксель, Отказ, ОписаниеОшибки) Экспорт
	
	КнигаЭксель = Неопределено;
	Попытка
		КнигаЭксель = Эксель.WorkBooks.Add();
	Исключение
		ОписаниеОшибки = "Не удалось добавить книгу. Описание ошибки: " + ОписаниеОшибки();
		Отказ = Истина;	
	КонецПопытки;
	
	Возврат КнигаЭксель;	
КонецФункции

Функция ком_ДобавитьЛистExcel(КнигаЭксель, ИмяЛиста = "", Отказ, ОписаниеОшибки) Экспорт
	
	ЛистЭксель = Неопределено;
	Попытка
		ЛистЭксель = КнигаЭксель.Worksheets.Add();
		
		Если ЗначениеЗаполнено(ИмяЛиста) Тогда
			ЛистЭксель.Name = ИмяЛиста;
		КонецЕсли;
	Исключение
		ОписаниеОшибки = "Не удалось добавить лист. Описание ошибки: " + ОписаниеОшибки();
		Отказ = Истина;	
	КонецПопытки;
	
	Возврат ЛистЭксель;
КонецФункции

////ЗАКРЫТЬ////
Процедура ком_ЗакрытьКнигуExcel(КнигаЭксель, Сохранение = 0) Экспорт
	
	Попытка
		КнигаЭксель.Close(Сохранение);
	Исключение
	КонецПопытки;
		
	КнигаЭксель = Неопределено;
	
КонецПроцедуры

Процедура ком_ЗакрытьExcel(Эксель) Экспорт
	
	Попытка
		Эксель.DisplayAlerts = 0;
		Эксель.Quit();
	Исключение
	КонецПопытки;
	
	Эксель = Неопределено;
	
КонецПроцедуры

////СЛУЖЕБНЫЕ////
Процедура ком_Пример(ПутьКФайлу)
	
	Отказ = Ложь;
	ОписаниеОшибки = "";
	
	Эксель = ком_ПолучитьExcel(Отказ, ОписаниеОшибки);
	Если Отказ Тогда
		Сообщить(ОписаниеОшибки);
		Возврат;
	КонецЕсли;
	
	КнигаЭксель = ком_ПолучитьКнигуExcel(Эксель, ПутьКФайлу, Отказ, ОписаниеОшибки);
	Если Отказ Тогда
		Сообщить(ОписаниеОшибки);
		Возврат;	
	КонецЕсли;
	
	КоличествоЛистов = КнигаЭксель.Sheets.Count;
	Для СчетчикПоЛистам = 1 По КоличествоЛистов Цикл
		Отказ = Ложь;
		ОписаниеОшибки = "";
		ЛистЭксель = ком_ПолучитьЛистExcel(КнигаЭксель, СчетчикПоЛистам, Отказ, ОписаниеОшибки);
		Если Отказ Тогда
			Сообщить("Не удалось открыть лист номер " + СчетчикПоЛистам + ". ОписаниеОшибки: " + ОписаниеОшибки);
			Продолжить;
		КонецЕсли;
		ТЧ = ком_ПрочитатьЛистExcel(ЛистЭксель);
		
	КонецЦикла;
	
	ком_ЗакрытьКнигуExcel(КнигаЭксель);
	ком_ЗакрытьExcel(Эксель);
	
КонецПроцедуры

Процедура ком_УбитьЗависшиеПроцессы() Экспорт
	//убивает процессы запущенные под текущим пользователем
	
	ИскатьЗависшиеПроцессы = Истина;
	ВыходИзРекурсии = 50; //50 попыток, потом выходим
	Пока ИскатьЗависшиеПроцессы Цикл
		
		Если ВыходИзРекурсии = 0 Тогда
			ИскатьЗависшиеПроцессы = Ложь;	
		КонецЕсли;
		
		Попытка
			Эксель = ПолучитьCOMОбъект(, "Excel.Application");
			ком_ЗакрытьExcel(Эксель);
			ВыходИзРекурсии = ВыходИзРекурсии -1;
		Исключение
			ИскатьЗависшиеПроцессы = Ложь;
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область МетодыДляРаботыЧерезOfficeOpenXML

////Чтение через XML////
Функция хмл_ПрочитатьЛистВТаблицуЗначений(ФайлEXCEL, ИмяНомерЛиста, СтрокаЗаголовка = 1, НачСтрока = 0, КонСтрока = 0, КонКолонка = 0) Экспорт
       
    ФайлНомерЛиста  = ИмяНомерЛиста.НомерЛиста;
    ФайлНомерЛиста = ?(ФайлНомерЛиста = 0, 1, ФайлНомерЛиста);
   
    ZIPКаталог = КаталогВременныхФайлов() + "XLSX\";	
	ОтветРаспаковки = хмл_ИзвлечьXLSXВКаталогZIP(ФайлEXCEL, ZIPКаталог);
	Если ОтветРаспаковки.Результат = Ложь Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	
    СоответствиеNumFmtIdFormatCode = Новый Соответствие;
    МассивNumFmtId = хмл_ИзвлечьДанныеИзФайла_StylesXML(ZIPКаталог, СоответствиеNumFmtIdFormatCode);
   
    МассивSharedStrings = хмл_ИзвлечьДанныеИзФайла_SharedStringsXML(ZIPКаталог);
   
    SheetX = Новый ЧтениеXML;
    SheetX.ОткрытьФайл(ZIPКаталог + "XL\WorkSheets\Sheet" + ФайлНомерЛиста + ".xml");
   
    МассивИменКолонокXLSX = хмл_ПолучитьМассивИменКолонокНаЛистеXLSX(SheetX);
    КолвоКолонокEXCEL = МассивИменКолонокXLSX.Количество();
		
    // Создание результирующей таблицы, в которую будут записываться считанные из EXCEL данные.
    ТаблицаРезультат = Новый ТаблицаЗначений;
    // Формирование колонок результирующей таблицы.
    // "НомерСтроки" - для наглядности и удобства.
    // В зависимости от разрабатываемой обработки.
    // "Сопоставлено" - может быть другим.
    // Здесь же могут быть добавлены другие колонки, не формируемые из содержимого файла EXCEL.
    ТаблицаРезультат.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"), "№", 4);
    ТаблицаРезультат.Колонки.Добавить("Сопоставлено", Новый ОписаниеТипов("Булево"), "Сопоставлено", 1);
    ТаблицаРезультат.Колонки.Добавить("УровеньГруппировки", Новый ОписаниеТипов("Число"), "Гр", 2); // Группировка строк в файле EXCEL.
    Для ит = 1 ПО КолвоКолонокExcel Цикл
        ИмяКолонки = "N" + ит;
        Колонка = ТаблицаРезультат.Колонки.Добавить(ИмяКолонки);
    КонецЦикла;
   
    SheetX = Новый ЧтениеXML;
    SheetX.ОткрытьФайл(ZIPКаталог + "XL\WorkSheets\Sheet" + ФайлНомерЛиста + ".xml");
   
    ЭтоНачалоДанных = Ложь;
    // Считать очередной узел XML.
    Пока SheetX.Прочитать() Цикл
        Если ВРег(SheetX.Имя) = "SHEETDATA" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            ЭтоНачалоДанных = Истина;
            Прервать;
        КонецЕсли;
    КонецЦикла;
    Если НЕ ЭтоНачалоДанных Тогда
        Возврат Новый ТаблицаЗначений;
    КонецЕсли;
   
    // Считать очередной узел XML.
    НомерСтроки = 0;
    Пока SheetX.Прочитать() Цикл
        Если ВРег(SheetX.Имя) = "SHEETDATA" И SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
            Прервать;   // Окончание данных.
        КонецЕсли;
        Если ВРег(SheetX.Имя) = "ROW" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            НомерСтроки = НомерСтроки + 1;
            Если НЕ НачСтрока = 0 И НомерСтроки < НачСтрока Тогда
                Продолжить;
            КонецЕсли;
            НоваяСтрока = ТаблицаРезультат.Добавить();
            НоваяСтрока.НомерСтроки = НомерСтроки;
            НоваяСтрока.УровеньГруппировки = SheetX.ЗначениеАтрибута("outlineLevel");
            Пока SheetX.Прочитать() Цикл    // Считаем колонки строки EXCEL.
                Если ВРег(SheetX.Имя) = "ROW" Тогда
                    Прервать;
                КонецЕсли;
                Если ВРег(SheetX.Имя) = "SHEETDATA" И SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
                    Прервать;   // Окончание данных.
                КонецЕсли;
                Если ВРег(SheetX.Имя) = "C" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                    ТипЗначения = SheetX.ЗначениеАтрибута("t");
                    ФорматЯчейки = SheetX.ЗначениеАтрибута("s");
                    ИмяКолонки = SheetX.ЗначениеАтрибута("r");
                    ИмяКолонкиБезЦифр = хмл_ЗаменитьОдниСимволыДругими("0123456789", ИмяКолонки, "");
                    ИндексКолонки = МассивИменКолонокXLSX.Найти(ИмяКолонкиБезЦифр)+1;
					
					//
					Если КонКолонка <> 0 И ИндексКолонки > КонКолонка Тогда
						Пока SheetX.Прочитать() Цикл
							Если ВРег(SheetX.Имя) = "ROW" Тогда
								Прервать;
							КонецЕсли;	
						КонецЦикла;
						Прервать;
					КонецЕсли;
					//
					
					SheetX.Прочитать();
                    Если ВРег(SheetX.Имя) = "V"  ИЛИ ВРег(SheetX.Имя) = "F" Тогда   // "V" - Значение, "F" - Формула.
                        Если ВРег(SheetX.Имя) = "F" Тогда
                            Пока НЕ ВРег(SheetX.Имя) = "V" Цикл
                                SheetX.Прочитать();
                            КонецЦикла;
                        КонецЕсли;
                        SheetX.Прочитать();
                        Если ВРег(SheetX.Имя) = "#TEXT" Тогда
                            ЗначениеЯчейки = SheetX.Значение;
                            ФорматСтиля = "";
                            Если (НЕ ФорматЯчейки = "" И НЕ ФорматЯчейки = Неопределено) Тогда
                                Попытка
                                    ИндексФормата = Число(ФорматЯчейки);
                                    ФорматСтиля = СоответствиеNumFmtIdFormatCode.Получить(МассивNumFmtId[ИндексФормата]);
                                Исключение
                                    ФорматСтиля = "";
                                КонецПопытки;
                            КонецЕсли;
                            Если ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
                                Если ТипЗначения = Неопределено ИЛИ ВРег(ТипЗначения) = "N" ИЛИ ВРег(ТипЗначения) = "B" Тогда
                                    Попытка
                                        Значение1 = Число(ЗначениеЯчейки);
                                    Исключение
                                        Значение1 = ЗначениеЯчейки;
                                    КонецПопытки;
                                    ЗначениеЯчейки = Значение1;
                                    Если (ФорматСтиля = "" ИЛИ ФорматСтиля = Неопределено) Тогда
                                        // ФорматСтиля = Неопределено - Атрибут "s" отсутствует.
                                        // MS Office (2010) может не формировать в xml-файле описание стиля форматирования для ячейки.
                                        // LibreOffice (4.1.5) формирует в xml-файле необходимые описания стиля форматирования ячейки.
                                        // Сообщить("Не определен стиль форматирования для кода " + ФорматЯчейки + " значения " + ЗначениеЯчейки);
                                    КонецЕсли;
                                   
                                    Если ТипЗнч(ЗначениеЯчейки) = Тип("Строка")
                                        И (Найти(ЗначениеЯчейки, "E-") > 0 ИЛИ Найти(ЗначениеЯчейки, "E+") > 0) Тогда
                                        ЗначениеЯчейки = хмл_ПолучитьЧислоВСтепениИзСтроковогоЗначения(ЗначениеЯчейки);
                                    КонецЕсли;
                                   
                                    Если ТипЗнч(ЗначениеЯчейки) = Тип("Число") Тогда
                                        // ПРОЦЕНТ.
                                        Если хмл_ЭтоПроцентXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
                                            ЗначениеЯчейки = Окр(ЗначениеЯчейки * 100, 3);
                                        // БУЛЕВО.
                                        ИначеЕсли хмл_ЭтоБулевоXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
                                            ЗначениеЯчейки = Булево(ЗначениеЯчейки);
                                        // ВРЕМЯ.
                                        ИначеЕсли хмл_ЭтоВремяXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
                                            ЗначениеЯчейки = хмл_КонвертироватьЧислоXLSXвДатуВремя(ЗначениеЯчейки);
                                        // ДАТА.
                                        ИначеЕсли хмл_ЭтоДатаXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
                                            ЗначениеЯчейки = хмл_КонвертироватьЧислоXLSXвДату(ЗначениеЯчейки);
                                        // ЧИСЛО.
                                        ИначеЕсли ТипЗначения = Неопределено
                                            ИЛИ ( хмл_ЭтоЧислоXLSX(ЗначениеЯчейки, ФорматСтиля)
                                            И НЕ хмл_ЭтоБулевоXLSX(ЗначениеЯчейки, ФорматСтиля)
                                            И НЕ хмл_ЭтоВремяXLSX(ЗначениеЯчейки, ФорматСтиля)
                                            И НЕ хмл_ЭтоДатаXLSX(ЗначениеЯчейки, ФорматСтиля) )
                                            Тогда
                                            // Без преобразования.
                                        Иначе
                                            // Прочие форматы.
                                        КонецЕсли;
                                       
                                    Иначе
                                       
                                        Сообщить("Не удалось преобразовать значение к ""числовому""(процент, время, дата, число) типу.");
                                       
                                    КонецЕсли;
                                   
                                ИначеЕсли ВРег(ТипЗначения) = "S" Тогда
                                   
                                    // МассивSharedStrings может быть пустым.
                                    Попытка
                                        ЗначениеЯчейки = СокрЛП(МассивSharedStrings[Число(SheetX.Значение)]);
                                    Исключение
                                        ЗначениеЯчейки = "";
                                    КонецПопытки;
                                   
                                ИначеЕсли ВРег(ТипЗначения) = "STR" Тогда
                       
                                    Если ТипЗнч(ЗначениеЯчейки) = Тип("Строка") Тогда
                                        ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
                                    КонецЕсли;
                       
                                КонецЕсли;
                            КонецЕсли;
                           
                            ИмяКолонки = "N"+ИндексКолонки;
                            НоваяСтрока[ИмяКолонки] = ЗначениеЯчейки;
                            // Используется при формировании таблицы на форме обработки.
                            ШиринаКолонки = ТаблицаРезультат.Колонки[ИмяКолонки].Ширина;
                            ДлинаСтроки = СтрДлина(СокрЛП(ЗначениеЯчейки));
                            ТаблицаРезультат.Колонки[ИмяКолонки].Ширина = ?(ШиринаКолонки < ДлинаСтроки, ДлинаСтроки, ШиринаКолонки);
                           
                        КонецЕсли;
                    КонецЕсли;
                КонецЕсли;
            КонецЦикла;
            Если НЕ КонСтрока = 0 И ((НомерСтроки + 1) > КонСтрока) Тогда
                Прервать;   // Окончание диапазона считываемых данных.
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
   
    // Завершение работы.
    // Закрытие Объектов.
    SheetX.Закрыть();
   
    хмл_УдалитьКолонкиСНулевойШириной(ТаблицаРезультат);
   
    Возврат ТаблицаРезультат;
   
КонецФункции


Функция хмл_ИзвлечьДанныеИзФайла_StylesXML(ZIPКаталог, СоответствиеNumFmtIdFormatCode)
    Перем Файл, Styles;
    Перем МассивNumFmtId, ит;
   
    МассивNumFmtId = Новый Массив;
    СоответствиеNumFmtIdFormatCode = Новый Соответствие;
   
    Файл = Новый Файл(ZIPКаталог + "XL\Styles.xml");
    Если НЕ Файл.Существует() Тогда
        Возврат МассивNumFmtId;
    КонецЕсли;
   
    Styles = Новый ЧтениеXML;
    Styles.ОткрытьФайл(Файл.ПолноеИмя);
   
    Пока Styles.Прочитать() Цикл
        Если ВРег(Styles.Имя) = ВРег("numFmt") И Styles.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            СоответствиеNumFmtIdFormatCode.Вставить(Styles.ЗначениеАтрибута("numFmtId"), ВРег(Styles.ЗначениеАтрибута("formatCode")));
        КонецЕсли;
        Если ВРег(Styles.Имя) = ВРег("cellXfs") Тогда
            Пока Styles.Прочитать() Цикл
                Если ВРег(Styles.Имя) = ВРег("xf") И Styles.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                    МассивNumFmtId.Добавить(Styles.ЗначениеАтрибута("numFmtId"));
                КонецЕсли;
            КонецЦикла;
        КонецЕсли;
    КонецЦикла;
   
    // Завершение работы.
    // Закрытие Объектов.
    Styles.Закрыть();

    // Проверка сопоставления кодов массива и соответствия.
    // MS Office может не формировать в xml-файле описание стиля форматирования для ячейки.
    // LibreOffice формирует в xml-файле необходимые описания стиля форматирования ячейки.
    Для Каждого ит ИЗ МассивNumFmtId Цикл
        Если СоответствиеNumFmtIdFormatCode.Получить(ит) = Неопределено Тогда
            Если ит = "0" Тогда    // Стандарт для числа (Целое число).
                СоответствиеNumFmtIdFormatCode.Вставить(ит, "GENERAL");
            ИначеЕсли ит = "9" ИЛИ ит = "10" Тогда    // Форматы для % ("0%", "0.00%").
                СоответствиеNumFmtIdFormatCode.Вставить(ит, "0%");
            ИначеЕсли ит = "14" ИЛИ ит = "16" Тогда    // Форматы для даты.
                СоответствиеNumFmtIdFormatCode.Вставить(ит, "DD.MM.YYYY");
            ИначеЕсли ит = "45" ИЛИ ит = "46" ИЛИ ит = "47" Тогда    // Форматы для времени.
                СоответствиеNumFmtIdFormatCode.Вставить(ит, "HH:MM:SS");
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
   
    Возврат МассивNumFmtId;
   
КонецФункции

Функция хмл_ИзвлечьДанныеИзФайла_SharedStringsXML(ZIPКаталог)
    Перем Файл, SharedStrings;
    Перем МассивSharedStrings;
   
    // Если в файле EXCEL не содержится значений, имеющих тип "СТРОКА", то файл "SharedStrings.xml" не формируется.
   
    МассивSharedStrings = Новый Массив;
   
    Файл = Новый Файл(ZIPКаталог + "XL\SharedStrings.xml");
    Если НЕ Файл.Существует() Тогда
        Возврат МассивSharedStrings;
    КонецЕсли;
   
    SharedStrings = Новый ЧтениеXML;
    SharedStrings.ОткрытьФайл(Файл.ПолноеИмя);
   
    Пока SharedStrings.Прочитать() Цикл
        Если ВРег(SharedStrings.Имя) = "#TEXT" Тогда
            МассивSharedStrings.Добавить(SharedStrings.Значение);
        КонецЕсли;
    КонецЦикла;
   
    // Завершение работы.
    // Закрытие Объектов.
    SharedStrings.Закрыть();
   
    Возврат МассивSharedStrings;
   
КонецФункции

Функция хмл_ПолучитьМассивИменКолонокНаЛистеXLSX(SheetX)
    Перем ДиапазонДанных, ДиапазонКолонок, ПерваяКолонка, ПоследняяКолонка, НомерПервойК, НомерПоследнейК;
    Перем Подсчет, ИмяКолонки;
    Перем МассивИменКолонокXLSX, КолвоКолонокEXCEL;
    
    МассивИменКолонокXLSX = Новый Массив;
    
    Подсчет = Ложь;
    // Считать очередной узел XML.
    Пока SheetX.Прочитать() Цикл
        // DIMENSION.
        Если ВРег(SheetX.Имя) = "DIMENSION" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            ДиапазонДанных     = SheetX.ПолучитьАтрибут("ref");
            ДиапазонКолонок = хмл_ЗаменитьОдниСимволыДругими("0123456789", ДиапазонДанных, "");
            ПерваяКолонка     = Лев(ДиапазонКолонок, Найти(ДиапазонКолонок ,":") - 1);
            ПоследняяКолонка= Сред(ДиапазонКолонок, Найти(ДиапазонКолонок ,":") + 1);
            НомерПервойК    = хмл_НомерКолонкиДесятичный(ПерваяКолонка);
            НомерПоследнейК    = хмл_НомерКолонкиДесятичный(ПоследняяКолонка);
        КонецЕсли;
		// Подсчет по 1-ой строке.
		Если ВРег(SheetX.Имя) = "ROW" Тогда
		    Если SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
		        // Начало отсчета.
		        Подсчет = Истина;
		    ИначеЕсли SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
		        // Окончание отсчета.
		        Прервать;
		    КонецЕсли;
		КонецЕсли;
		Если Подсчет И ВРег(SheetX.Имя) = "C" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
		    ИмяКолонки = SheetX.ПолучитьАтрибут("r");
		    ИмяКолонки = хмл_ЗаменитьОдниСимволыДругими("0123456789", ИмяКолонки, "");
		    МассивИменКолонокXLSX.Добавить(ИмяКолонки);
		КонецЕсли;
    КонецЦикла;
	
	//хмл_ДополнитьМассивИменКолонокXLSX(НомерПоследнейК, МассивИменКолонокXLSX);
	
	КолвоКолонокEXCEL = МассивИменКолонокXLSX.Количество();
	Если НЕ НомерПоследнейК = Неопределено Тогда
	    Если КолвоКолонокEXCEL < НомерПоследнейК Тогда
			//Сообщить("Строка заголовков колонок (1-я строка) заполнена не полностью:
			//|К-во колонок строки меньше объявленной: " + КолвоКолонокEXCEL + "<" + НомерПоследнейК);
	        хмл_ДополнитьМассивИменКолонокXLSX(НомерПоследнейК, МассивИменКолонокXLSX);
	    ИначеЕсли КолвоКолонокEXCEL > НомерПоследнейК Тогда
	        Сообщить("Строка заголовков колонок (1-я строка) содержит больше колонок, чем объявлено:
	        |К-во колонок строки больше объявленной:" + КолвоКолонокEXCEL + ">" + НомерПоследнейК);
	    КонецЕсли;
	КонецЕсли;
        
    Возврат МассивИменКолонокXLSX;
    
КонецФункции

Функция хмл_НомерКолонкиДесятичный(ИмяКолонкиXLSX)
    Перем Латиница, ДлинаНомера, Поз, ит;
    Перем НомерКолонки;
    
    Латиница = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";    // 26.
    ДлинаНомера = СтрДлина(ИмяКолонкиXLSX);
    НомерКолонки = 0;
    Для ит = 1 ПО ДлинаНомера Цикл
        Поз = Найти(Латиница, Сред(ИмяКолонкиXLSX, (ДлинаНомера + 1 - ит), 1));
        НомерКолонки = НомерКолонки + Поз * Pow(26, ит - 1);
    КонецЦикла;
    
    Возврат НомерКолонки;
    
КонецФункции

Процедура хмл_ДополнитьМассивИменКолонокXLSX(Знач КолвоКолонокExcel, МассивИменКолонокXLSX, Индекс = - 1)
    Перем Алфавит, ит, Буква;
    
    Алфавит = хмл_РазложитьСтрокуВМассивПодстрок("A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z", ",");
    
    Если МассивИменКолонокXLSX.Количество() >= КолвоКолонокExcel Тогда
        Возврат;
    КонецЕсли;
    
    Если Индекс > Алфавит.Количество() - 1 Тогда
        Возврат;
    КонецЕсли;
    
    Буква = ?(Индекс = -1, "", Алфавит[Индекс]);
    Для ит = 0 ПО Алфавит.Количество() - 1 Цикл
        Если МассивИменКолонокXLSX.Найти(Буква + Алфавит[ит]) = Неопределено Тогда
            МассивИменКолонокXLSX.Добавить(Буква + Алфавит[ит]);
        КонецЕсли;
        Если МассивИменКолонокXLSX.Количество() >= КолвоКолонокExcel Тогда
            Возврат;
        КонецЕсли;
    КонецЦикла;
    
    Если МассивИменКолонокXLSX.Количество() > КолвоКолонокExcel Тогда
        Возврат;
    Иначе
        Индекс = Индекс + 1;
        хмл_ДополнитьМассивИменКолонокXLSX(КолвоКолонокExcel, МассивИменКолонокXLSX, Индекс);
    КонецЕсли;
    
    Возврат;
    
КонецПроцедуры

// Функция "расщепляет" строку на подстроки, используя заданный
//      разделитель. Разделитель может иметь любую длину.
//      Если в качестве разделителя задан пробел, рядом стоящие пробелы
//      считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//      игнорируются.
//      Например,
//      РазложитьСтрокуВМассивПодстрок(",один,,,два", ",") возвратит массив значений из пяти элементов,
//      три из которых - пустые строки, а
//      РазложитьСтрокуВМассивПодстрок(" один   два", " ") возвратит массив значений из двух элементов
//
//  Параметры:
//      Стр -           строка, которую необходимо разложить на подстроки.
//                      Параметр передается по значению.
//      Разделитель -   строка-разделитель, по умолчанию - запятая.
//
//  Возвращаемое значение:
//      массив значений, элементы которого - подстроки
//
Функция хмл_РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",")
    
    МассивСтрок = Новый Массив();
    Если Разделитель = " " Тогда
        Стр = СокрЛП(Стр);
        Пока 1 = 1 Цикл
            Поз = Найти(Стр, Разделитель);
            Если Поз = 0 Тогда
                МассивСтрок.Добавить(СокрЛП(Стр));
                Возврат МассивСтрок;
            КонецЕсли;
            МассивСтрок.Добавить(СокрЛП(Лев(Стр, Поз - 1)));
            Стр = СокрЛ(Сред(Стр, Поз));
        КонецЦикла;
    Иначе
        ДлинаРазделителя = СтрДлина(Разделитель);
        Пока 1 = 1 Цикл
            Поз = Найти(Стр, Разделитель);
            Если Поз = 0 Тогда
                Если (СокрЛП(Стр) <> "") Тогда
                    МассивСтрок.Добавить(СокрЛП(Стр));
                КонецЕсли;
                Возврат МассивСтрок;
            КонецЕсли;
            МассивСтрок.Добавить(СокрЛП(Лев(Стр,Поз - 1)));
            Стр = Сред(Стр, Поз + ДлинаРазделителя);
        КонецЦикла;
    КонецЕсли;
   
КонецФункции

Функция хмл_ЭтоЧислоXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
   
    Если ( ВРег(ФорматСтиля) = "GENERAL"
        ИЛИ ВРег(ФорматСтиля) = "STANDARD"
        ИЛИ Найти(ФорматСтиля, "0") > 0 )
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_ЭтоПроцентXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
   
    Если ( Найти(ФорматСтиля, "%") > 0 )
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_ЭтоБулевоXLSX(ЗначениеЯчейки, ФорматСтиля)
   
    Если (ЗначениеЯчейки = 0 ИЛИ ЗначениеЯчейки = 1)
        И Найти(ВРег(ФорматСтиля), "ИСТИНА") > 0 ИЛИ Найти(ВРег(ФорматСтиля), "ЛОЖЬ") > 0
        ИЛИ Найти(ВРег(ФорматСтиля), "TRUE") > 0 ИЛИ Найти(ВРег(ФорматСтиля), "FALSE") > 0
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_ЭтоДатаXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
   
    Если ЗначениеЯчейки = Цел(ЗначениеЯчейки) И
        ( Найти(ФорматСтиля, "DD") > 0
        ИЛИ Найти(ФорматСтиля, "MM") > 0
        ИЛИ Найти(ФорматСтиля, "YY") > 0
        ИЛИ Найти(ФорматСтиля, "QQ") > 0
        ИЛИ Найти(ФорматСтиля, "WW") > 0 )
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_ЭтоВремяXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
   
    Если ЗначениеЯчейки < 1 И
        ( Найти(ФорматСтиля, "HH:") > 0
        ИЛИ Найти(ФорматСтиля, "[HH]:") > 0
        ИЛИ Найти(ФорматСтиля, "[H]:") > 0
        ИЛИ Найти(ФорматСтиля, "MM:") > 0
        ИЛИ Найти(ФорматСтиля, ":SS") > 0 )
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_КонвертироватьЧислоXLSXвДату(Знач Число)
    Перем Дата1900, Разница, ДатаРезультат;
   
    Дата1900 = Дата("19000101");
   
    Разница = Число - 2;    // EXCEL ошибочно считает 1900-й год високосным.
    Разница = ?(Разница < 0, 0, Разница);
   
    ДатаРезультат = Дата1900 + Разница * 24 * 60 * 60;
   
    Возврат ДатаРезультат;
   
КонецФункции

Функция хмл_КонвертироватьЧислоXLSXвДатуВремя(Знач Число)
    Перем КВоСекунд;
    Перем ВремяРезультат;
   
    // 0,0000115740740740741 = 1 сек.
    // 1                     = 24 часа 00 мин 00 сек.
   
    Если ТипЗнч(Число) = Тип("Число") Тогда
        КВоСекунд = Число * 100000 / 1.15740740740741;
        КВоСекунд = Окр(КВоСекунд);
    Иначе
        Сообщить("Ошибка определения значения типа ""Время"".");
    КонецЕсли;
   
    ВремяРезультат = Дата("19000101000000") + КВоСекунд;
   
    Возврат ВремяРезультат;
   
КонецФункции

Функция хмл_ПолучитьЧислоВСтепениИзСтроковогоЗначения(Знач ЗначениеЯчейки)
    Перем Поз1Е, Степень;
    Перем Значение;
   
    Если Найти(ЗначениеЯчейки, "E-") > 0 Тогда
        Поз1Е = Найти(ЗначениеЯчейки, "E-");
        Степень = Сред(ЗначениеЯчейки, Поз1Е+2);
        Значение = Лев(ЗначениеЯчейки, Поз1Е-1);
        Попытка
            Степень = Число(Степень);
            Значение = Число(Значение) / Pow(10, Степень);
        Исключение
            Значение = ЗначениеЯчейки;
        КонецПопытки;
    ИначеЕсли Найти(ЗначениеЯчейки, "E+") > 0 Тогда
        Поз1Е = Найти(ЗначениеЯчейки, "E+");
        Степень = Сред(ЗначениеЯчейки, Поз1Е+2);
        Значение = Лев(ЗначениеЯчейки, Поз1Е-1);
        Попытка
            Степень = Число(Степень);
            Значение = Число(Значение) * Pow(10, Степень);
        Исключение
            Значение = ЗначениеЯчейки;
        КонецПопытки;
    Иначе
        Значение = ЗначениеЯчейки;
    КонецЕсли;
   
    Возврат Значение;
   
КонецФункции

Функция хмл_ЗаменитьОдниСимволыДругими(ЗаменяемыеСимволы, Строка, СимволыЗамены)
    Результат = Строка;
    Для НомерСимвола = 1 По СтрДлина(ЗаменяемыеСимволы) Цикл
        Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, НомерСимвола, 1), Сред(СимволыЗамены, НомерСимвола, 1));
    КонецЦикла;
    Возврат Результат;
КонецФункции

Процедура хмл_УдалитьКолонкиСНулевойШириной(ТаблицаРезультат)
    Перем МассивПустыхКолонок;
    // Найдем пустые колонки.
    МассивПустыхКолонок = Новый Массив;
    Для Каждого Колонка ИЗ ТаблицаРезультат.Колонки Цикл
        Если Колонка.Ширина = 0 Тогда
            МассивПустыхКолонок.Добавить(Колонка.Имя);
        КонецЕсли;
    КонецЦикла;
    // Удалим пустые колонки.
    Для Каждого ПустаяКолонка ИЗ МассивПустыхКолонок Цикл
        ТаблицаРезультат.Колонки.Удалить(ПустаяКолонка);
    КонецЦикла;
КонецПроцедуры


////запись через XML////
Процедура ОбработатьЯчейкуСДанными(СтараяВерсияXML, НоваяВерсияXML, ЯчейкиКЗамене, флПродолжить)
	
	Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ВРег(СтараяВерсияXML.Имя) = "C" Тогда
		флПродолжить = Истина;
		флЯчейкаКЗамене = Ложь;
		НовоеЗначение = 0;
		
		ИмяКолонки = СтараяВерсияXML.ЗначениеАтрибута("r");					
		Если ЯчейкиКЗамене[ИмяКолонки] <> Неопределено Тогда
			НовоеЗначение = ЯчейкиКЗамене[ИмяКолонки];
			флЯчейкаКЗамене = Истина;	
		КонецЕсли;
		
		НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
		Пока СтараяВерсияXML.ПрочитатьАтрибут() Цикл
			НоваяВерсияXML.ЗаписатьАтрибут(СтараяВерсияXML.Имя, СтараяВерсияXML.Значение);				
		КонецЦикла;
		
		СтараяВерсияXML.Прочитать();
		
		//элемент "С" имеет пустое значение 
		//добавляем значение, если ячейка к замене
		Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ВРег(СтараяВерсияXML.Имя) = "C" Тогда
			//добавляем значение
			Если флЯчейкаКЗамене Тогда
				НоваяВерсияXML.ЗаписатьНачалоЭлемента("v");
				НоваяВерсияXML.ЗаписатьТекст(НовоеЗначение);
				НоваяВерсияXML.ЗаписатьКонецЭлемента();
			КонецЕсли;
			
			//записываем значение элемента "С"
			НоваяВерсияXML.ЗаписатьКонецЭлемента();
			
			Возврат; //пустая ячейка
		КонецЕсли;	
		
		//элемент "С" без формул
		//подменяем значение, если ячейка к замене
		Если ВРег(СтараяВерсияXML.Имя) = "V" Тогда
			Если флЯчейкаКЗамене Тогда
				НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
				НоваяВерсияXML.ЗаписатьТекст(НовоеЗначение);
				НоваяВерсияXML.ЗаписатьКонецЭлемента();
				
				Пока СтараяВерсияXML.Прочитать() Цикл
					Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			Иначе
				НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
				СтараяВерсияXML.Прочитать();
				Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.Текст Тогда
					НоваяВерсияXML.ЗаписатьТекст(СтараяВерсияXML.Значение);
					СтараяВерсияXML.Прочитать();
					НоваяВерсияXML.ЗаписатьКонецЭлемента();
				ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
					НоваяВерсияXML.ЗаписатьКонецЭлемента();	
				КонецЕсли;
			КонецЕсли;
			
			//прочитаем и запишем конец элемента "С"
			СтараяВерсияXML.Прочитать();
			НоваяВерсияXML.ЗаписатьКонецЭлемента();
			
			Возврат;
		КонецЕсли;
		
		//элемент "С" с формулой
		//данные из элемента "F" переносим
		//данные из элемента "V" очищаем, чтобы при открытии экселя значения формул пересчитались
		Если ВРег(СтараяВерсияXML.Имя) = "F" Тогда
			НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
			Пока СтараяВерсияXML.ПрочитатьАтрибут() Цикл
				НоваяВерсияXML.ЗаписатьАтрибут(СтараяВерсияXML.Имя, СтараяВерсияXML.Значение);				
			КонецЦикла;
		
			СтараяВерсияXML.Прочитать();
			Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.Текст Тогда
				НоваяВерсияXML.ЗаписатьТекст(СтараяВерсияXML.Значение);
				СтараяВерсияXML.Прочитать();
				НоваяВерсияXML.ЗаписатьКонецЭлемента();
			ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
				НоваяВерсияXML.ЗаписатьКонецЭлемента();	
			КонецЕсли;	
		 
			СтараяВерсияXML.Прочитать();
			//элемент "V" пропускаем и не записываем
			Если ВРег(СтараяВерсияXML.Имя) = "V" Тогда
				Пока СтараяВерсияXML.Прочитать() Цикл
					Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
						СтараяВерсияXML.Прочитать();
						Прервать;
					КонецЕсли;
				КонецЦикла;
			Иначе
				а=1;
			КонецЕсли;
			
			//записываем значение элемента "С"
			НоваяВерсияXML.ЗаписатьКонецЭлемента();
			
			//читаем след строку, чтобы правильно отработала логика процедуре из которой вызвали
			Возврат;
		КонецЕсли;	
	КонецЕсли;
	
КонецПроцедуры

Функция хмл_ИзменитьДанныеЯчеекНаЛисте(ПутьКФайлуИсточнику, ИмяНомерЛиста, ЯчейкиКЗамене) Экспорт
	
	ОтветФункции = Новый Структура;
	ОтветФункции.Вставить("Результат", Ложь);
	ОтветФункции.Вставить("ОписаниеОшибки", "");
	ОтветФункции.Вставить("ПутьКФайлуИсточнику", ПутьКФайлуИсточнику);
	ОтветФункции.Вставить("ПутьКФайлуПриемнику", "");
	
	//проверяем файл эксель и распаковываем, как архив
	КаталогZIP = КаталогВременныхФайлов() + "XLSX\";
	ОтветРаспаковки = хмл_ИзвлечьXLSXВКаталогZIP(ПутьКФайлуИсточнику, КаталогZIP);
	Если ОтветРаспаковки.Результат = Ложь Тогда
		ОтветФункции.ОписаниеОшибки = ОтветРаспаковки.ОписаниеОшибки;
		
		Возврат ОтветФункции;
	КонецЕсли;
	
	//инициализация переменных
	ФайлНомерЛиста  = ИмяНомерЛиста.НомерЛиста;
    ФайлНомерЛиста = ?(ФайлНомерЛиста = 0, 1, ФайлНомерЛиста);
	
	ИмяФайлаЛиста = "Sheet" + ФайлНомерЛиста + ".xml"; 
	КаталогЛистов = "XL\WorkSheets\";
	ПутьКфайлуЛиста = КаталогZIP + КаталогЛистов + ИмяФайлаЛиста;
	
	//копируем xml, чтоб избежать блокировки файла, в который будем новые данные писать
	ПутьККопииФайлаЛиста = ПолучитьИмяВременногоФайла("xml");
	КопироватьФайл(ПутьКфайлуЛиста, ПутьККопииФайлаЛиста);
	
	//основной код
	//читаем построчно копию файла листа, подменяем данные и записываем в основной файл листа
	СтараяВерсияXML = Новый ЧтениеXML;
    СтараяВерсияXML.ОткрытьФайл(ПутьККопииФайлаЛиста);
	
	НоваяВерсияXML = Новый ЗаписьXML;
	НоваяВерсияXML.ОткрытьФайл(ПутьКфайлуЛиста);
	НоваяВерсияXML.ЗаписатьОбъявлениеXML();
	
	Пока СтараяВерсияXML.Прочитать() Цикл
		флПродолжить = Ложь;
		ОбработатьЯчейкуСДанными(СтараяВерсияXML, НоваяВерсияXML, ЯчейкиКЗамене, флПродолжить);
		Если флПродолжить Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда			
			НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
			Пока СтараяВерсияXML.ПрочитатьАтрибут() Цикл
				НоваяВерсияXML.ЗаписатьАтрибут(СтараяВерсияXML.Имя, СтараяВерсияXML.Значение);				
			КонецЦикла;
		ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.Текст Тогда
			НоваяВерсияXML.ЗаписатьТекст(СтараяВерсияXML.Значение);				
		ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			НоваяВерсияXML.ЗаписатьКонецЭлемента();				
		ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.ИнструкцияОбработки Тогда
			НоваяВерсияXML.ЗаписатьИнструкциюОбработки(СтараяВерсияXML.Имя, СтараяВерсияXML.Значение);
		ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.Комментарий Тогда
			НоваяВерсияXML.ЗаписатьКомментарий(СтараяВерсияXML.Значение);		
		КонецЕсли;
	КонецЦикла;
	НоваяВерсияXML.Закрыть();
	
	//запаковыем измененные данные обратно в xlsx
	ПутьКФайлуПриемнику = ПолучитьИмяВременногоФайла("xlsx");
	хмл_ЗапаковатьКаталогВXLSX(ПутьКФайлуПриемнику, КаталогZIP);
	ОтветФункции.ПутьКФайлуПриемнику = ПутьКФайлуПриемнику;
	
	//
	УдалитьФайлы(КаталогZIP);
	ОтветФункции.Результат = Истина;
	Возврат ОтветФункции;
	
КонецФункции

////Работа с архиватором////
Функция хмл_ИзвлечьXLSXВКаталогZIP(ПутьКФайлуXLSX, КаталогZIP)

	ОтветФункции = Новый Структура;
	ОтветФункции.Вставить("Результат", Ложь);
	ОтветФункции.Вставить("ОписаниеОшибки", "");
	ОтветФункции.Вставить("ПутьКФайлуXLSX", ПутьКФайлуXLSX);
	ОтветФункции.Вставить("КаталогZIP", КаталогZIP);
	
	Если НЕ ЗначениеЗаполнено(ПутьКФайлуXLSX) Тогда
		ОтветФункции.ОписаниеОшибки = "Файл не найден, т.к. передан пустой путь к файлу XLSX";
		
		Возврат ОтветФункции;
    КонецЕсли;
   
    ФайлXLSX = Новый Файл(ПутьКФайлуXLSX);
	Если НЕ ФайлXLSX.Существует() Тогда
		ТекстОшибки = "Файл не существует. Путь к файлу: %1";
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, ПутьКФайлуXLSX);
		
		Возврат ОтветФункции;
	КонецЕсли;
	
	Если НЕ ВРег(ФайлXLSX.Расширение) = ".XLSX" Тогда		
		ТекстОшибки = "Файл с расширением %1 не поддерживается методом NativeXLSX: %2";;
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, ФайлXLSX.Расширение, ПутьКФайлуXLSX);
		
		Возврат ОтветФункции;
	КонецЕсли;
	
	Попытка
		ПереместитьФайл(ФайлXLSX.ПолноеИмя,ФайлXLSX.ПолноеИмя);
	Исключение
		ТекстОшибки = "Файл занят другим процессом. Описание ошибки: %1";
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		Возврат ОтветФункции;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(КаталогZIP);
		
		ZIPФайл = Новый ЧтениеZipФайла;
		ZIPФайл.Открыть(ПутьКФайлуXLSX);
		ZIPФайл.ИзвлечьВсе(КаталогZIP, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Исключение
		ТекстОшибки = "Не удалось распаковать файл. Описание ошибки: %1";
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		Возврат ОтветФункции;
	КонецПопытки;
	
	ОтветФункции.Результат = Истина;
	Возврат ОтветФункции;
	
КонецФункции

Функция хмл_ЗапаковатьКаталогВXLSX(ПутьКФайлуXLSX, КаталогZIP)

	ОтветФункции = Новый Структура;
	ОтветФункции.Вставить("Результат", Ложь);
	ОтветФункции.Вставить("ОписаниеОшибки", "");
	
	Попытка
		ЗипФайл = Новый ЗаписьZipФайла;
		ЗипФайл.Открыть(ПутьКФайлуXLSX);
		ЗипФайл.Добавить(КаталогZIP+"*", РежимСохраненияПутейZIP.СохранятьОтносительныеПути, РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);	
		ЗипФайл.Записать();
	Исключение
		ТекстОшибки = "Не удалось запаковать файл. Описание ошибки: %1";
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		Возврат ОтветФункции;
	КонецПопытки;

	ОтветФункции.Результат = Истина;
	Возврат ОтветФункции;
	
КонецФункции

#КонецОбласти

#Область МетодыДляРаботыЧерезТабличныйДокумент

////Чтение через ТабличныйДокумент////
Функция тд_ПрочитатьЛистВТаблицуЗначений(Знач ФайлEXCEL, Знач ИмяЛиста = "", Знач СтрокаЗаголовка = 1, НачСтрока = 0, КонСтрока = 0, КолвоСтрокФайла = 0) Экспорт
	Перем ТабличныйДокумент, ОбластьФайла, КолВоКолонокФайла, ИмяКолонки, Область, ТекущаяОбласть, нСтрока, нКолонка, НоваяСтрокаТФ, ЗначениеЯчейки;
	Перем ТаблицаРезультат;
	
	СтруктураОтвета = новый Структура;
	СтруктураОтвета.Вставить("КоличествоСтрок");
	СтруктураОтвета.Вставить("КоличествоКолонок");
	СтруктураОтвета.Вставить("ТаблицаРезультат");
	СтруктураОтвета.Вставить("ЕстьОшибки", Ложь);	
	СтруктураОтвета.Вставить("ОписаниеОшибки");
	СтруктураОтвета.Вставить("ТекущийМетод","ТабличныйДокумент");
		
	ТабличныйДокумент = Новый ТабличныйДокумент;
	Попытка
		// Выполняется долго на больших файлах.
		
		// СпособЧтенияЗначенийТабличногоДокумента - новый параметр платформы 8.3.6. Второе значение "Текст".
		ТабличныйДокумент.Прочитать(ФайлEXCEL, СпособЧтенияЗначенийТабличногоДокумента.Значение);    
	Исключение
					
		СтруктураОтвета.ОписаниеОшибки = ОписаниеОшибки();			
		СтруктураОтвета.ЕстьОшибки = Истина;
		Возврат СтруктураОтвета;
		
	КонецПопытки;
		
	//ОбластьФайла = ТабличныйДокумент.ПолучитьОбласть(ИмяЛиста);
	
	ОбластиТабДок = ТабличныйДокумент.Области;
	ОбластьФайла = ТабличныйДокумент.ПолучитьОбласть(ОбластиТабДок[0].Имя);
				
	КолВоСтрокФайла = ОбластьФайла.ПолучитьРазмерОбластиДанныхПоВертикали();
	КолВоКолонокФайла = ОбластьФайла.ПолучитьРазмерОбластиДанныхПоГоризонтали();
		
	// Проверка заполненности листа.
	Если КолвоСтрокФайла = 0 Тогда
		// Завершение работы.
		// Закрытие Объектов.
		ТабличныйДокумент = Неопределено;
				
		СтруктураОтвета.ОписаниеОшибки = "КолвоСтрокФайла = 0";
		СтруктураОтвета.ЕстьОшибки = Истина;
		Возврат СтруктураОтвета;
	КонецЕсли;
	
	// Создание результирующей таблицы, в которую будут записываться считанные из файла данные.
	ТаблицаРезультат = Новый ТаблицаЗначений;
	
	// Формирование колонок результирующей таблицы.
	
	// "НомерСтроки" - для наглядности и удобства.
	// В зависимости от разрабатываемой обработки.
	// Здесь же могут быть добавлены другие колонки, не формируемые из содержимого файла.
	ТаблицаРезультат.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"), "№", 4);
		
	Для ит = 1 ПО КолВоКолонокФайла Цикл
		нКолонка = СтрЗаменить(ит, Символы.НПП, "");
		ИмяКолонки = "Колонка" + нКолонка;
		ТаблицаРезультат.Колонки.Добавить(ИмяКолонки);
	КонецЦикла;
	
	// 1-я строка. Заголовки.
	НоваяСтрокаТФ = ТаблицаРезультат.Добавить();
	НоваяСтрокаТФ.НомерСтроки = 1;
	Для ит=1 ПО КолВоКолонокФайла Цикл
		нКолонка = СтрЗаменить(ит, Символы.НПП, "");
		ИмяКолонки = "Колонка" + нКолонка;
		НоваяСтрокаТФ[ИмяКолонки] = ОбластьФайла.ПолучитьОбласть("R1" + "C"+нКолонка).ТекущаяОбласть.Текст;
		
		// Используется при формировании таблицы на форме обработки.
		ШиринаКолонки = ТаблицаРезультат.Колонки[ИмяКолонки].Ширина;
		ДлинаСтроки    = СтрДлина(СокрЛП(НоваяСтрокаТФ[ИмяКолонки]));
		ТаблицаРезультат.Колонки[ИмяКолонки].Ширина = ?(ШиринаКолонки < ДлинаСтроки, ДлинаСтроки, ШиринаКолонки);
	КонецЦикла;
	
	НачСтрока = ?(НачСтрока = 0, 2, НачСтрока);
	КонСтрока = ?(КонСтрока = 0, КолвоСтрокФайла, КонСтрока);
	
	Для нСтрокаТФ = НачСтрока ПО КонСтрока Цикл
		НоваяСтрокаТФ = ТаблицаРезультат.Добавить();
		НоваяСтрокаТФ[0] = нСтрокаТФ;
		нСтрока = СтрЗаменить(нСтрокаТФ, Символы.НПП, "");
		Для нКолонкаТФ = 1 ПО КолВоКолонокФайла Цикл
			нКолонка = СтрЗаменить(нКолонкаТФ, Символы.НПП, "");
			Область = ОбластьФайла.ПолучитьОбласть("R"+нСтрока+"C"+нКолонка);
			ТекущаяОбласть = Область.ТекущаяОбласть;
			Попытка
				ЗначениеЯчейки = ТекущаяОбласть.Значение;        // Число, Дата.
			Исключение
				ЗначениеЯчейки = СокрЛП(ТекущаяОбласть.Текст);    // Строка, Булево. (Булево как строка "ИСТИНА"/"ЛОЖЬ")
				Если ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
					ЗначениеЯчейки = тд_ПреобразоватьПростоеЗначениеИзСтрокиВТипизованноеЗначение1С(ЗначениеЯчейки);
					Если ТипЗнч(ЗначениеЯчейки) = Тип("Строка") Тогда
						ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
					КонецЕсли;
				Иначе
					ЗначениеЯчейки = Неопределено;
					Если Область.Рисунки.Количество() > 0 Тогда    // Изображение.
						ЗначениеЯчейки = тд_ПолучитьЗначениеЯчейкиОбластиТабличногоДокументаСКартинками(Область, нСтрока, нКолонка, "УИД");
					КонецЕсли;
				КонецЕсли;
			КонецПопытки;
			
			ИмяКолонки = "Колонка" + нКолонка;
			НоваяСтрокаТФ[ИмяКолонки] = ЗначениеЯчейки;
			
			// Используется при формировании таблицы на форме обработки.
			ШиринаКолонки = ТаблицаРезультат.Колонки[ИмяКолонки].Ширина;
			ДлинаСтроки    = СтрДлина(СокрЛП(НоваяСтрокаТФ[ИмяКолонки]));
			ТаблицаРезультат.Колонки[ИмяКолонки].Ширина = ?(ШиринаКолонки < ДлинаСтроки, ДлинаСтроки, ШиринаКолонки);
		КонецЦикла;
	КонецЦикла;
	
	
	// Удалить пустые колонки.	
	тд_УдалитьКолонкиСНулевойШириной(ТаблицаРезультат);
		
	СтруктураОтвета.КоличествоСтрок = ТаблицаРезультат.Количество();
	СтруктураОтвета.КоличествоКолонок = ТаблицаРезультат.Колонки.Количество();
		
	СтруктураОтвета.ТаблицаРезультат = ТаблицаРезультат;
	Возврат СтруктураОтвета;	
	
КонецФункции

Процедура тд_УдалитьКолонкиСНулевойШириной(ТаблицаРезультат)
	Перем МассивПустыхКолонок;
	
	// Найдем пустые колонки.
	МассивПустыхКолонок = Новый Массив;
	Для Каждого Колонка ИЗ ТаблицаРезультат.Колонки Цикл
		Если Колонка.Ширина = 0 Тогда
			МассивПустыхКолонок.Добавить(Колонка.Имя);
		КонецЕсли;
	КонецЦикла;
	
	// Удалим пустые колонки.
	Для Каждого ПустаяКолонка ИЗ МассивПустыхКолонок Цикл
		ТаблицаРезультат.Колонки.Удалить(ПустаяКолонка);
	КонецЦикла;
	
КонецПроцедуры

Функция тд_ПолучитьЗначениеЯчейкиОбластиТабличногоДокументаСКартинками(Знач Область, Знач нСтрока, Знач нКолонка, Знач ПравилоИмяФайлаКартинки = "УИД")
	Перем Рисунок, ит, ИмяФайлаРисунка;
	Перем ЗначениеЯчейки;
	
	ит = 0;
	ЗначениеЯчейки = "";
	Для Каждого Рисунок ИЗ Область.Рисунки Цикл
		ит = ит + 1;
		Если ПравилоИмяФайлаКартинки = "УИД" Тогда
			ИмяФайлаРисунка = КаталогВременныхФайлов() + Новый УникальныйИдентификатор() + ".jpg";
		Иначе
			ИмяФайлаРисунка = КаталогВременныхФайлов() + "С" + нСтрока + "Колонка" + нКолонка + ".jpg";
		КонецЕсли;
		Попытка
			Рисунок.Картинка.Записать(ИмяФайлаРисунка);
			ЗначениеЯчейки = ЗначениеЯчейки + ИмяФайлаРисунка + ?(ит < Область.Рисунки.Количество(), Символы.ПС, "");
		Исключение
			// Поле картинки недоступно для чтения.
		КонецПопытки;
	КонецЦикла;
	
	Возврат ЗначениеЯчейки;
	
КонецФункции

Функция тд_ПреобразоватьПростоеЗначениеИзСтрокиВТипизованноеЗначение1С(Знач ИсходноеЗначение)
	
	Если НЕ ИсходноеЗначение = "" Тогда
		Если тд_ТолькоЦифрыИЗапятаяВСтроке(ИсходноеЗначение, Истина, Ложь) Тогда
			Попытка
				Возврат Число(ИсходноеЗначение);
			Исключение
				Возврат ИсходноеЗначение
			КонецПопытки;
		Иначе
			Если ВРег(ИсходноеЗначение) = "ИСТИНА" ИЛИ ВРег(ИсходноеЗначение) = ("ИСТИНА"+Символы.ПС) ИЛИ ВРег(ИсходноеЗначение) = "TRUE" ИЛИ ВРег(ИсходноеЗначение) = ("TRUE"+Символы.ПС) Тогда
				Возврат Истина;
			ИначеЕсли ВРег(ИсходноеЗначение) = "ЛОЖЬ" ИЛИ  ВРег(ИсходноеЗначение) = ("ЛОЖЬ"+Символы.ПС) ИЛИ ВРег(ИсходноеЗначение) = "FALSE" ИЛИ ВРег(ИсходноеЗначение) = ("FALSE"+Символы.ПС) Тогда
				Возврат Ложь;
			Иначе								
				Возврат ИсходноеЗначение;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ИсходноеЗначение;
	
КонецФункции

Функция тд_ТолькоЦифрыИЗапятаяВСтроке(Знач СтрокаПроверки, Знач УчитыватьЛидирующиеНули = Истина, Знач УчитыватьПробелы = Истина)
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если Сред(СтрокаПроверки, 1, 1) = "-" Тогда
		СтрокаПроверки = Сред(СтрокаПроверки, 2, СтрДлина(СтрокаПроверки));
	КонецЕсли;
	
	Если ПустаяСтрока(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		Позиция = 1;
		// Взятие символа за границей строки возвращает пустую строку
		Пока Сред(СтрокаПроверки, Позиция, 1) = "0" Цикл
			Позиция = Позиция + 1;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, Позиция);
	КонецЕсли;
	
	// Если содержит только цифры, то в результате замен должна быть получена пустая строка
	// Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы
	Возврат СтрДлина(
	СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
	СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
	СтрокаПроверки, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", ""), ",", "")
	) = 0;
	
КонецФункции

#КонецОбласти
